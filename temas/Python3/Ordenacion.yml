Subject: 6
Title: Algoritmos de ordenación
Intro: bla bla bla
Lessons:
 - Title: Introducción
   Elements:
    - Elem: Text
      Content: |
          bla bla bla
 - Title: Ordenación por selección
   Elements:
    - Elem: Text
      Content: |
          bla bla bla
 - Title: Ordenación por inserción
   Elements:
    - Elem: Text
      Content: |
          bla bla bla
 - Title: Ordenación de burbuja
   Elements:
    - Elem: Text
      Content: |
          bla bla bla          
 - Title: Quicksort
   Elements:
    - Elem: Text
      Content: |
          # Quicksort

          Los algoritmos de ordenación que acabáis de aprender son los conocidos como *cuadráticos*, ya que en el peor
          de los casos deben hacer una cantidad de comparaciones proporcional a @@n^2@@ para ordenar una lista de
          tamaño @@n@@. A continuación aprenderemos el
          algoritmo **quicksort**, que permite reducir el número de comparaciones a @@n \times \mathit{log}~n@@ en el caso
          promedio. Por lo tanto, permite ordenar listas en menos tiempo que la ordenación por *inserción*, *selección*
          o *burbuja*.
    - Elem: Text
      Content: |
          # Ideas básicas

          La función ```quicksort(l)``` acepta una lista ```l``` y devuelve una lista ordenada. Para ello sigue estos pasos:
          * Si la lista está **vacía** o tiene **un único elemento** entonces ya está ordenada y únicamente hay que devolver la lista.
          * En otro caso, toma un elemento de la lista de manera aleatoria (usualmente el primer elemento). Este elemento escogido se conoce como **pivote**.
              1. Divide la lista (sin contar el pivote) en dos partes. Para ello toma por un lado los elementos menores o iguales que el pivote y por otro los elementos mayores que el pivote.
              1. De manera recursiva, se ordenan estas dos listas más pequeñas.
              1. Finalmente, las listas ordenadas se concatenan con el pivote en la mitad.
    - Elem: Text
      Content: |
          # Ejemplo

          Consideremos la lista desodenada ```l = [5, 7, 3, 1]```. La ejecución de *quicksort* realizaría:
          1. Como ```l``` no es una lista vacía, se toma ```5``` como **pivote**.
          1. Se divide la lista restante ```[7, 3, 1]```` en dos partes (recuerda que se ignora el pivote). Esto creará dos listas:
              * ```less_eq = [3, 1]```
              * ```greater = [7]```
          1. A continuación, se ordena cada una de estas listas de manera recursiva invocando a ```quicksort```. Esto creará otras dos listas:
              * ```sorted_less_eq = [1, 3]```
              * ```sorted_greater = [7]```
          1. Finalmente concatenamos ```sorted_less_eq``` seguido del pivote y de ```sorted_greater```. El resultado de
             esta concatenación será ```[1, 3] + [5] + [7] = [1, 3, 5, 7]```, es decir, la lista ordenada.
    - Elem: Text
      Content: |
          # Funciones auxiliares

          Para implementar el algoritmo *quicksort* es necesario ser capaces de, a partir de una lista, elegir un
          pivote y dividir la lista en los partes: los elementos menores o iguales y los elementos mayores.

          La función auxiliar ```partition(l)``` realiza ese trabajo. Para ello selecciona el primer elemento como pivote
          ```piv``` y recorre el resto de la lista mediante un bucle ```while```. Cada vez que encuentra un elemento menor o igual que pivote lo
          almacena en la lista ```less_eq```, y cada vez que encuentra un elemento mayor que pivote lo almacena en la
          lista ```greater```.
          ```

          def partition(l):
              piv = l[0]
              i = 1
              less_eq = []
              greater = []
              while i < len(l):
                  current = l[i]
                  if current <= piv:
                      less_eq.append(current)
                  else:
                      greater.append(current)
                  i = i + 1
              return (less_eq, piv, greater)
          ```
          Finalmente, la función ```partition``` devuelve una tupla de 3 elementos: la lista ```less_eq```, el pivote
          ```piv``` y la lista ```greater```.
    - Elem: Options
      Content: |
          Considerando el código de la función ```partition``` presentado anteriormente:

          ```

          def partition(l):
              piv = l[0]
              i = 1
              less_eq = []
              greater = []
              while i < len(l):
                  current = l[i]
                  if current <= piv:
                      less_eq.append(current)
                  else:
                      greater.append(current)
                  i = i + 1
              return (less_eq, piv, greater)
          ```
          ¿Qué debería devolver la siguiente llamada ```partition([])```?
      Hint: Revisa bien cómo se elige el pivote.
      Solution: [4]
      Multiple: no
      Options:
          - La tupla ([], None, [])
          - La tupla ([], [])
          - La lista vacía []
          - Debería fallar al tratar de acceder al primer elemento de la lista vacía.
    - Elem: Code
      Content: |
          Considerando de nuevo el código de la función ```partition``` presentado anteriormente:

          ```

          def partition(l):
              piv = l[0]
              i = 1
              less_eq = []
              greater = []
              while i < len(l):
                  current = l[i]
                  if current <= piv:
                      less_eq.append(current)
                  else:
                      greater.append(current)
                  i = i + 1
              return (less_eq, piv, greater)
          ```
          ¿Qué debería devolver la llamada ```partition([6,3,9,2,4])```?
      Gaps: 1
      Prompt: ["Valor devuelto por partition([6,3,9,2,4])"]
      Hint: ¿Qué elemento tiene que ir a cada lista? ¿Qué elemento es el pivote?
      File: correctores/ordenacion/quicksort1.py
    - Elem: Code
      Content: |
          Considerando de nuevo el código de la función ```partition``` presentado anteriormente:

          ```

          def partition(l):
              piv = l[0]
              i = 1
              less_eq = []
              greater = []
              while i < len(l):
                  current = l[i]
                  if current <= piv:
                      less_eq.append(current)
                  else:
                      greater.append(current)
                  i = i + 1
              return (less_eq, piv, greater)
          ```
          ¿Qué debería devolver la llamada ```partition([1,2,3,4,5])```?
      Gaps: 1
      Prompt: ["Valor devuelto por partition([1,2,3,4,5])"]
      Hint: ¿Qué elemento tiene que ir a cada lista? ¿Qué elemento es el pivote?
      File: correctores/ordenacion/quicksort2.py
    - Elem: Text
      Content: |
          # Código de ```quicksort```

          Utilizando la función ```partition``` es muy sencillo implementar la función ```quicksort``` para ordenar
          listas:

          ```

          def quicksort(l):
              # Base case, the same list is returned.
              if len(l) <= 1:
                  return l
              # Recursive case:
              else:
                  (less_eq, piv, greater) = partition(l)
                  sorted_less_eq = quicksort(less_eq)
                  sorted_greater = quicksort(greater)
                  return sorted_less_eq + [piv] + sorted_greater
          ```

          Si la longitud de la lista es igual o inferior a 1 (```len(l) <= 1```) entonces está ordenada y se puede devolver
          directamente.

          En otro caso se invoca a ```partition``` para obtener el pivote ```piv``` y las listas de elementos
          menores o iguales (```less_eq```) y mayores (```greater```). A continuación se ordenan estas listas de manera
          recursiva con llamadas a ```quicksort```:
          * sorted_less_eq = ```quicksort(less_eq)```
          * sorted_greater = ```quicksort(greater)```

          Finalmente, se devuelven los elementos menores o iguales **ordenados**, seguidos del pivote y de los elementos
          mayores **ordenados**. Esta operación se realiza con la siguiente concatenación de listas:
          ```

          return sorted_less_eq + [piv] + sorted_greater
          ```
          Notad que el operador ```+``` concatena listas, por lo que debemos crear la lista unitaria ```[piv]``` para que la
          concatenación de las 3 partes tenga éxito.
    - Elem: Code
      Content: |
          Vamos a comprobar que habéis entendido bien el código de quicksort. **Sin volver atrás** para revisar el
          código, trata de rellenar los huecos ```<Hueco 0>``` y ```<Hueco 1>``` en el siguiente código. En estos
          huecos deberían aparecer las llamadas recursivas.

          ```

          def quicksort(l):
              # Base case, the same list is returned.
              if len(l) <= 1:
                  return l
              # Recursive case:
              else:
                  (less_eq, piv, greater) = partition(l)
                  sorted_less_eq = <Hueco 0>
                  sorted_greater = <Hueco 1>
                  return sorted_less_eq + [piv] + sorted_greater
          ```
      Gaps: 2
      Hint: quicksort() deber ordenar las partes separadas por partition()
      File: correctores/ordenacion/quicksort3.py
    - Elem: Code
      Content: |
          Por último, vamos a comprobar las intuiciones que habéis formado sobre el código de ```quicksort```.
          ¿Qué valor debería tomar la variable ```sorted_less_eq``` en la llamada inicial de

          ```

          quicksort([6,2,7,3,8,0])
          ```

          A modo de recordatorio, el código de ```quicksort``` es el siguiente:
          ```

          def quicksort(l):
              # Base case, the same list is returned.
              if len(l) <= 1:
                  return l
              # Recursive case:
              else:
                  (less_eq, piv, greater) = partition(l)
                  sorted_less_eq = quicksort(less_eq)
                  sorted_greater = quicksort(greater)
                  return sorted_less_eq + [piv] + sorted_greater
          ```
      Gaps: 1
      Prompt: ["Valor de sorted_less_eq"]
      Hint: Trata de calcular los valores que van tomando las variables anteriores a sorted_less_eq.
      File: correctores/ordenacion/quicksort4.py
    - Elem: Code
      Content: |
          Y considerando la misma llamada

          ```

          quicksort([6,2,7,3,8,0])
          ```

          ¿Qué valor debería tomar la variable ```sorted_greater``` en la llamada inicial?
          A modo de recordatorio, el código de ```quicksort``` es el siguiente:
          ```

          def quicksort(l):
              # Base case, the same list is returned.
              if len(l) <= 1:
                  return l
              # Recursive case:
              else:
                  (less_eq, piv, greater) = partition(l)
                  sorted_less_eq = quicksort(less_eq)
                  sorted_greater = quicksort(greater)
                  return sorted_less_eq + [piv] + sorted_greater
          ```
      Gaps: 1
      Prompt: ["Valor de sorted_greater"]
      Hint: Trata de calcular los valores que van tomando las variables anteriores a sorted_greater.
      File: correctores/ordenacion/quicksort5.py
 - Title: Mergesort
   Elements:
    - Elem: Text
      Content: |
          # Mergesort

          El algoritmo **mergesort** es otro algoritmo de ordenación *rápido*, al igual que *quicksort*. En otras
          palabras, para ordenar una lista de @@n@@ elementos necesitará realizar como mucho @@n \times \mathit{log}~n@@
          comparaciones, en lugar de las @@n^2@@ de la ordenación por *insercción*, *selección* o *burbuja*.

          Las ideas principales son similares a *quicksort*: dividir la lista original en dos partes,
          ordenar cada parte y por último componer la lista completa ordenada a partir de sus partes ordenadas. Sin
          embargo, difiere en cómo realiza la división de la lista, como veremos más adelante.
    - Elem: Text
      Content: |
          # Ideas básicas

          El algoritmo **mergesort** ordena una lista dividiéndola en **2 mitades**, ordenando cada mitad resultante y
          por último combinando esas 2 mitades ordenadas utilizando una función auxiliar ```merge```.

          La función ```merge```
          combina dos listas ordenadas manteniendo el orden de sus elementos, es decir,
          cogiendo en cada momento el menor elemento que
          aparece en las cabeza de las listas.

          Concretamente, ```mergesort``` realiza los siguientes pasos:
          * Si la lista está **vacía o tiene un solo elemento** ya está ordenada y se devuelve directamente.
          * Si la lista tiene **2 o más elementos**:
            1. Divide la lista original en dos mitades
            1. Invoca recursivamente al método ```mergesort``` para ordenar cada mitad de lista
            1. Finalmente, combina las dos mitades ordenadas mediante la función auxiliar ```merge```. El resultado de
               esta combinación es la lista original ordenada, que se devuelve.
    - Elem: Text
      Content: |
          # Ejemplo

          Consideremos la lista desodenada ```l = [5, 7, 3, 1]```. La ejecución de *mergesort* realizaría:
          1. Como ```l``` no es una lista vacía, se divide en 2 mitades. La posición central será ```half = len(l) // 2```,
             que en este caso es ```4 // 2 = 2```. Nótese el uso de la división entera para evitar decimales al tratar
             listas de longitud impar.
          1. Se divide la lista orignal ```l``` en dos mitades: ```l1 = l[:half]``` con los elementos en posiciones desde
             ```0``` hasta ```half-1```, y ```l2 = l[half:]``` con los elementos en posiciones desde ```half``` hasta el
             final de la lista. En este caso:
               * ```l1 = [5, 7]```
               * ```l2 = [3, 1]```
          1. Cada una de estas listas se ordena de manera recursiva, obtenindo dos mitades ordenadas.
               * ```sorted_l1 = [5, 7]```
               * ```sorted_l2 = [1, 3]```
          1. Finalmente se mezclan de manera ordenada ambas listas ordenadas usando la función auxiliar ```merge```,
             generando la lista inicial ordenada ```[1, 3, 5, 7]```
    - Elem: Text
      Content: |
          # Función ```merge```

          Antes de ver el código concreto de ```mergesort``` estudiaremos la función auxiliar ```merge```. Esta función
          toma dos **listas ordenadas** ```l1``` y ```l2``` y las combina de manera ordenada, generando una lista ordenada
          ```merged_list```. Para ello recorre ambas listas en orden usando dos índices ```i``` y ```j```:
          * ```i```: posición del siguiente elemento a procesar de la lista ```l1```
          * ```j```: posición del siguiente elemento a procesar de la lista ```l2```

          En cada momento, compara ```l1[i]``` y ```l2[j]```:
          * Si ```l1[i] <= l2[j]``` entonces inserta ```l1[i]``` al final de la lista ordenada ```merged_list``` ya que es menor
            o igual a ```l2[j]``` y por tanto debería ir antes. Como se ha procesado el elemento ```l1[i]``` se incrementa el
            índice ```i```.
          * Si no, ```l1[i] > l2[j]``` e inserta ```l2[j]``` al final de la lista ordenada ```merged_list```.
            Como se ha procesado el elemento ```l2[j]``` se incrementa el índice ```j```.

          Este proceso se repite hasta que una de las dos listas se acaba (o bien ```i == len(l1)``` o bien ```j == len(l2)```).
          En ese momento se deja de comparar elementos y se añaden a la lista ordenada ```merged_list``` los elementos
          restantes de la lista que aún tiene elementos por procesar.
    - Elem: Text
      Content: |
          # Código de la función ```merge```

          El código concreto de la función ```merge``` sería el siguiente:

          ```

          def merge(l1, l2):
              i = 0
              j = 0
              merged_list = []
              while i < len(l1) and j < len(l2):
                  if l1[i] <= l2[j]:
                      merged_list.append(l1[i])
                      i = i + 1
                  else:
                      merged_list.append(l2[j])
                      j = j + 1
              while i < len(l1):
                  merged_list.append(l1[i])
                  i = i + 1
              while j < len(l2):
                  merged_list.append(l2[j])
                  j = j + 1
              return merged_list
          ```

          Esta función contiene 3 bucles ```while```:
          1. El primer bucle recorre en orden y compara los elementos ```l1[i]``` y ```l2[j]``` hasta que una de las
             dos listas se termina. En cada iteración añade un nuevo elemento a la lista ordenada ```merged_list```.
          1. El segundo bucle recorre los posibles elementos restantes de ```l1``` y los añade en orden a la lista ordenada ```merged_list```.
          1. El tercer bucle recorre los posibles elementos restantes de ```l2``` y los añade en orden a la lista ordenada ```merged_list```.

          Es importante darse cuenta de que al terminar el primer bucle se habrá terminado de recorrer exactamente una de las 2 listas.
          Si es la primera lista entonces ```i == len(l1)``` y no se entrará en el segundo bucle. Si es la segunda lista la que
          se ha terminado de recorrer entonces ```j == len(l2)``` y no se entrará en el tercer bucle. Se podría haber realizado
          una distinción de casos para elegir qué bucle ejecutar, pero la propia condición de los bucles segundo y tercero
          consigue que únicamente se entre en uno de ellos.
    - Elem: Options
      Content: |
          Considerando el código de la función ```merge``` presentado anteriormente:
          ```

          def merge(l1, l2):
              i = 0
              j = 0
              merged_list = []
              while i < len(l1) and j < len(l2):
                  if l1[i] <= l2[j]:
                      merged_list.append(l1[i])
                      i = i + 1
                  else:
                      merged_list.append(l2[j])
                      j = j + 1
              while i < len(l1):
                  merged_list.append(l1[i])
                  i = i + 1
              while j < len(l2):
                  merged_list.append(l2[j])
                  j = j + 1
              return merged_list
          ```

          ¿Qué debería devolver la siguiente llamada ```merge([],[])```?
      Hint: Revisa bien las condiciones de los distintos bucles.
      Solution: [3]
      Multiple: no
      Options:
        - None
        - (None, None)
        - []
        - ([], [])
    - Elem: Options
      Content: |
          Siguiendo con el código de la función ```merge``` presentado anteriormente:
          ```

          def merge(l1, l2):
              i = 0
              j = 0
              merged_list = []
              while i < len(l1) and j < len(l2):
                  if l1[i] <= l2[j]:
                      merged_list.append(l1[i])
                      i = i + 1
                  else:
                      merged_list.append(l2[j])
                      j = j + 1
              while i < len(l1):
                  merged_list.append(l1[i])
                  i = i + 1
              while j < len(l2):
                  merged_list.append(l2[j])
                  j = j + 1
              return merged_list
          ```

          ¿Qué debería devolver la llamada ```merge([8],[1,9])```?
      Hint: Revisa bien las condiciones de los distintos bucles.
      Solution: [1]
      Multiple: no
      Options:
        - [1, 8, 9]
        - [8, 1, 9]
        - [1, 9, 8]
    - Elem: Code
      Content: |
          Otra pregunta más sobre la función auxiliar ```merge```.

          ```

          def merge(l1, l2):
              i = 0
              j = 0
              merged_list = []
              while i < len(l1) and j < len(l2):
                  if l1[i] <= l2[j]:
                      merged_list.append(l1[i])
                      i = i + 1
                  else:
                      merged_list.append(l2[j])
                      j = j + 1
              while i < len(l1):
                  merged_list.append(l1[i])
                  i = i + 1
              while j < len(l2):
                  merged_list.append(l2[j])
                  j = j + 1
              return merged_list
          ```

          ¿Qué debería devolver la llamada ```merge([1,4,8],[])```?
      Gaps: 1
      Prompt: ["Resultado de merge([1,4,8],[])"]
      Hint: Trata de ver qué bucles se ejecutarán.
      File: correctores/ordenacion/mergesort1.py
    - Elem: Options
      Content: |
          Ya estamos familiarizados con la función auxiliar ```merge``` que mezcla de manera ordenada dos listas ordenadas.
          Pero, ¿qué pasaría si se invoca con listas que no están ordenadas? Por ejemplo, con la siguiente inovocación:

          ```

          merge([5, 1], [3, 2])
          ```

          ¿Qué produciría la invocación anterior?
      Hint: Revisa bien las condiciones de los distintos bucles.
      Solution: [2]
      Multiple: no
      Options:
        - Lanza un error en tiempo de ejecución
        - Genera una lista de 4 elementos pero desordenada
        - Genera la lista ordenda [1, 2, 3, 5]
        - Genera la lista de 2 elementos [1, 5] ya que únicamente recorre la primera lista
    - Elem: Text
      Content: |
          # Versión alternativa de ```merge```

          El código de la función auxiliar ```merge``` se puede simplificar si utilizamos dos métodos de las listas:
            * ```l.pop(n)``` para eliminar el elemento en posición ```n``` de la lista ```l```
            * ```l.extend(l1)``` para concatenar ```l1``` al final de ```l```

          Con estos dos métodos podríamos eliminar completamente el uso de los índices ```i``` y ```j``` e implementar ```merge``` como sigue:
          ```

          def merge_bis(l1, l2):
              merged_list = []
              while l1 != [] and l2 != []:
                  if l1[0] <= l2[0]:
                      merged_list.append(l1[0])
                      l1.pop(0)
                  else:
                      merged_list.append(l2[0])
                      l2.pop(0)
              merged_list.extend(l1)
              merged_list.extend(l2)
              return merged_list
          ```
          Como se puede ver, las listas ```l1``` y ```l2``` se van vaciando con ```pop[0]``` y la condición del primer
          bucle comprueba que las listas ```l1``` y ```l2``` no sean vacías. Finalmente, usamos ```merge_list.extend(l1)```
          y ```merge_list.extend(l2)``` para concatenar los elementos restantes. De manera similar a la versión anterior
          de ```merge```, al terminar el primer bucle tenemos la certeza que **una de las dos listas (```l1``` o ```l2```)
          estará vacía**.
    - Elem: Text
      Content: |
          # Código de ```mergesort```

          Disponiendo de una función auxiliar ```merge``` (o ```merge_bis```) es bastante sencillo implementar la función de ordenación
          ```mergesort```:

          ```

          def mergesort(l):
              if len(l) <= 1:
                  return l
              else:
                  half = (len(l) // 2)
                  l1 = mergesort(l[:half])
                  l2 = mergesort(l[half:])
                  return merge(l1, l2)
          ```
          Si la lista está **vacía o tiene un solo elemento** ya está ordenada y se devuelve directamente.

          En otro caso (la lista tiene **2 o más elementos**) se divide la lista en 2 mitades. Para ello se calcula la
          posición central de la lista con la asignación ```half = (len(l) // 2)```, que usa la división entera.

          A continuación invoca de manera recursiva a ```mergesort``` con cada una de las dos mitades:
            1. La primera mitad de la lista será ```l[:half]```: *posiciones [0..half)*
            1. La segunda mitad de la lista será ```l[half:]```: *posiciones [half..n)*, siendo *n* la longitud de ```l```

          El resultado de las dos llamadas recursivas serán dos mitades ordenadas ```l1``` y ```l2```. Por lo tanto el
          último paso será mezclar de manera ordenadas ambas mitades ordenadas. Para ello invocaremos a la función
          auxiliar ```merge```.
    - Elem: Code
      Content: |
          Vamos a comprobar que habéis entendido bien el código de ```mergesort```. **Sin volver atrás** para revisar el
          código, trata de rellenar los huecos ```<Hueco 0>``` y ```<Hueco 1>``` en el siguiente código.

          ```

          def mergesort(l):
              if len(l) <= 1:
                  return lst
              else:
                  half = <Hueco 0>
                  l1 = mergesort(l[:half])
                  l2 = mergesort(l[half:])
                  return <Hueco 1>
          ```
      Gaps: 2
      Hint: Habría que calcular la mitad y combinar de alguna manera las listas l1 y l2
      File: correctores/ordenacion/mergesort2.py
    - Elem: Code
      Content: |
          Por último, vamos a comprobar las intuiciones que habéis formado sobre el código de ```mergesort```.
          ¿Qué valor debería tomar la variable ```l1``` en la llamada inicial de

          ```

          mergesort([6,8,2,4,1])
          ```

          A modo de recordatorio, el código de ```mergesort``` es el siguiente:
          ```

          def mergesort(l):
              if len(l) <= 1:
                  return l
              else:
                  half = (len(l) // 2)
                  l1 = mergesort(l[:half])
                  l2 = mergesort(l[half:])
                  return merge(l1, l2)
          ```  return <Hueco 1>
      Gaps: 1
      Prompt: ["Valor de la variable l1"]
      Hint: Es el resultado de una llamada recursiva con un trozo de la lista original.
      File: correctores/ordenacion/mergesort3.py
    - Elem: Code
      Content: |
          Y considerando la misma llamada

          ```

          mergesort([6,8,2,4,1])
          ```
          ¿Qué valor debería tomar la variables ```l2```?

          Al igual que antes, a modo de recordatorio el código de ```mergesort``` es el siguiente:
          ```

          def mergesort(l):
              if len(l) <= 1:
                  return l
              else:
                  half = (len(l) // 2)
                  l1 = mergesort(l[:half])
                  l2 = mergesort(l[half:])
                  return merge(l1, l2)
          ```  return <Hueco 1>
      Gaps: 1
      Prompt: ["Valor de la variable l2"]
      Hint: Es el resultado de una llamada recursiva con un trozo de la lista original.
      File: correctores/ordenacion/mergesort4.py