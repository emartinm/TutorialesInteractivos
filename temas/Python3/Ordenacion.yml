Subject: 6
Title: Algoritmos de ordenación
Intro: En este tema veremos distintos algoritmos para ordenar listas. Empezaremos viendo algoritmos más intuitivos pero que "le cuestan más" al ordenador, es decir, que necesitan más pasos para devolver el resultado. Después veremos algoritmos más elaborados y que son los que realmente implementan internamente los lenguajes como Python. Aprende bien estos últimos, pues las funciones auxiliares que usan y las propias ideas que siguen se aplican en muchos más campos.
Lessons:
 - Title: Ordenación por selección
   Elements:
    - Elem: Text
      Content: |
          # Ordenación por selección

          El objetivo de estos algoritmos es la *ordenación de listas de datos*. Dada una lista de @@n@@ elementos el resultado
          de estos algoritmos será una lista con los mismos @@n@@ elementos pero en orden. El orden concreto queda definido
          en base a lo que se establezca en el algoritmo. Nosotros, para simplificar, vamos a devolver siempre listas de números ordenadas
          *de menor a mayor*. Empezaremos con el algoritmo de *selección* que es uno de los más intuitivos.
    - Elem: Text
      Content: |
          # Ideas básicas

          La función ```seleccion(l)``` acepta una lista ```l``` y devuelve una lista ordenada. Para ello sigue estos pasos:
          * Empieza desde el primer elemento de la lista.
          * Después, se busca el elemento más pequeño en el resto de la lista. En este punto puede ocurrir una de estas dos situaciones:
              1. Que el más pequeño del resto de la lista no sea menor que primer elemento de la lista. En este caso no hacemos nada.
              1. Que encontremos que el elemento más pequeño del resto de la lista es menor que el primero. En este caso, se intercambian las
              posiciones. Por tanto, el valor del primer elemento de la lista pasa a ser el mínimo obtenido, y viceversa.
          * Con esto ya tenemos en la primera posición el elemento más pequeño. Ahora se hará exactamente lo mismo empezando esta vez por el
          segundo elemento de la lista. Continuará el proceso hasta llegar al último elemento, momento en el cual la lista ya estará ordenada.
    - Elem: Text
      Content: |
          # Ejemplo

          Consideremos la lista desordenada ```l = [3, 2, 4, 1]```. La ejecución de *seleccion(l)* realizaría:
          1. Se toma ```l[0] = 3``` y se busca el mínimo en el resto de la lista, es decir en ```[2, 4, 1]```. En este caso, el mínimo será ```l[3] = 1```.
          Por tanto, intercambiamos sus posiciones, es decir, ```l[0] = 1``` y ```l[3] = 3```. Con esto la lista queda: ```l = [1, 2, 4, 3]```.
          1. Se toma ahora ```l[1] = 2```, y se busca el mínimo en el resto de la lista, es decir en ```[4, 3]```. El mínimo en este caso es ```l[3] = 3```,
          sin embargo, su valor no es menor a ```l[1] = 2```. Por tanto, la lista no se modifica.
          1. Seguimos con ```l[2] = 4``` y buscamos el mínimo en ```[3]```. En este caso, el mínimo es ```l[3] = 3```, que a su vez es más pequeño que
          ```l[2] = 4```, con lo cual los intercambiamos. Obtenemos ```l = [1, 2, 3, 4]```
          1. Solo queda un elemento por procesar ```l[3] = 4```, pero como el resto de la lista es vacío, no hacemos nada y el algoritmo termina dejando
          la lista efectivamente ordenada.
    - Elem: Options
      Content: |
          Siguiendo las ideas y ejemplos de las páginas anteriores, vamos a intentar completar el esqueleto de la función ```selection(lst)```
          que implementa el algoritmo de selección que hemos visto:

          ```

          def selection(lst):
              for i in range(len(lst)):
                  pmin = <INICIALIZACIÓN DE PMIN>
                  for j in range(i,len(lst)):
                      if lst[j] < lst[pmin]:
                          pmin = <ACTUALIZACIÓN DE PMIN>
                  <INTERCAMBIO DE DATOS>
          ```
          El algoritmo empieza con un bucle que recorre todos los elementos de la lista con el índice @@i@@.
          ¿Qué debería contener el ```<INICIALIZACIÓN DE PMIN>```?
      Hint: Se empieza con el primer elemento, luego el segundo, etc.
      Solution: [2]
      Multiple: no
      Options:
          - len(lst) - 1
          - i
          - 0
          - lst[i]
    - Elem: Options
      Content: |
          Seguimos completando el esqueleto de ```selection(lst)```:

          ```

          def selection(lst):
              for i in range(len(lst)):
                  pmin = i
                  for j in range(i,len(lst)):
                      if lst[j] < lst[pmin]:
                          pmin = <ACTUALIZACIÓN DE PMIN>
                  <INTERCAMBIO DE DATOS>
          ```
          El bucle para el índice @@j@@ recorre todas las posiciones que van después de @@i@@ para
          encontrar el mínimo. Para eso, en el condicional **pmin** cuando el valor encontrado es
          menor que el que llevábamos hasta ahora.
          ¿Qué debería contener el ```<ACTUALIZACIÓN DE PMIN>```?
      Hint: Debemos guardar la posición que contiene el valor más pequeño.
      Solution: [3]
      Multiple: no
      Options:
          - lst[pmin]
          - i
          - j
          - lst[j]
    - Elem: Code
      Content: |
          Seguimos completando el esqueleto de ```selection(lst)```:

          ```

          def selection(lst):
              for i in range(len(lst)):
                  pmin = i
                  for j in range(i,len(lst)):
                      if lst[j] < lst[pmin]:
                          pmin = j
                  <INTERCAMBIO DE DATOS>
          ```
          Una vez finalizado el bucle para @@j@@, debemos intercambiar los valores.
          Escribe el código de ```<INTERCAMBIO DE DATOS>```
      Gaps: 1
      Hint: Hay que fijarse para no perder el valor de algún elemento de la lista.
      File: correctores/ordenacion/selection1.py
    - Elem: Text
      Content: |
          # Vista del algoritmo completo

          ```

          def selection(lst):
              for i in range(len(lst)):
                  pmin = i
                  for j in range(i,len(lst)):
                      if lst[j] < lst[pmin]:
                          pmin = j
                  tmp = lst[i]
                  lst[i] = lst[pmin]
                  lst[pmin] = tmp
          ```
 - Title: Ordenación por inserción
   Elements:
    - Elem: Text
      Content: |
          # Ordenación por inserción

          Este algoritmo de ordenación ordena las listas insertando elemento en una lista parcialmente ordenada.
          Básicamente lo que hace este algoritmo es iterar cada elemento de la lista de izquierda a derecha. Al finalizar
          cada iteración queda una lista ordenada desde el principio de la lista hasta ese elemento. Por tanto, en el siguiente
          elemento de la iteración se sabe que la lista de la izquierda está ordenada. Este principio es básico para el funcionamiento
          de este algoritmo.
    - Elem: Text
      Content: |
          # Ideas básicas

          La función ```insercion(l)``` acepta una lista ```l``` y devuelve una lista ordenada. Para ello sigue estos pasos:
          * Empieza desde el primer elemento de la lista. Sea el número que sea, desde la izquierda hasta ese elemento se forma una lista de
          un solo elemento que está naturalmente ordenada.
          * Se sigue insertando con el segundo elemento. Este caso ya es más interesante. Ahora sabemos que la lista de la izquierda es una lista ordenada.
          Por tanto, vamos a insertarlo ordenado en esta lista. Pueden ocurrir tres situaciones.
              1. Que la lista esté vacía, con lo cual el elemento ya está donde debe estar. Es lo que ocurre con el primer elemento de la lista.
              1. Que nos encontremos con un elemento que sea menor o igual. En este caso no se hace nada, ya que la lista que queda ya está ordenada.
              1. Que nos encontremos con un elemento que sea mayor. En este caso lo que hace es intercambiar las posiciones de estos dos elementos
               ya que el elemento que estamos insertando debe ir antes del último. Este mismo proceso se sigue hasta llega alguna de las dos primeras situaciones.
          * Al finalizar obtenemos ya una lista ordenada hasta el segundo elemento. Ahora se hará exactamente lo mismo insertando esta vez el
          tercer elemento de la lista. Continuará el proceso hasta llegar al último elemento, y tras su inserción la lista ya estará ordenada.
    - Elem: Text
      Content: |
          # Ejemplo

          Consideremos la lista desordenada ```l = [3, 2, 4, 1]```. La ejecución de *insercion(l)* realizaría:
          1. Se toma ```l[0] = 3```, y en este caso no se modifica nada de la lista. La lista desde la posición ```0``` hasta la posición 0 está naturalmente ordenada, es decir ```[3]```.
          1. Se toma ahora ```l[1] = 2```, que se compara con el último elemento de la lista que empieza en ```0``` y acaba en el elemento de su izquierda, es decir ```[3]```.
          En este caso ```l[1] = 2``` es menor que el último elemento de esta lista, es decir ```3```. Por tanto se intercambian posiciones, es decir ```l[0] = 2``` y ```l[1] = 3```. Ya no queda más lista a su izquierda, por tanto la lista queda
          ```l = [2, 3, 4, 1]```, donde se aprecia que la sublista hasta ```l[1]``` está ordenada, es decir ```[2, 3]```.
          1. Seguimos con ```l[2] = 4```. En este caso, el valor es mayor que el último de la sublista de su izquierda, por tanto la lista ya está ordenada, quedando como sublista ```[2, 3, 4]```.
          1. Solo queda un elemento por procesar ```l[3] = 1```, siendo la sublista de la izquierda ```[2, 3, 4]```. Al comparar con el último elemento y ser menor, esto implica que se deben intercambiar, , es decir ```l[3] = 4``` y ```l[2] = 1```,
          quedando la lista ```l = [2, 3, 1, 4]```. Lo mismo ocurre al comparar con la sublista ```[2, 3]```, por tanto se obtiene ```l = [2, 1, 3, 4]```. Finalmente, la lista de la izquierda es ```[2]```, por tanto se debe volver a intercambiar,
          obteniendo la lista final que está efectivamente ordenada ```l = [1, 2, 3, 4]```.
    - Elem: Options
      Content: |
          Siguiendo las ideas y ejemplos anteriores, vamos a intentar completar el esqueleto de la función ```insertion(lst)```
          que implementa el algoritmo anterior:

          ```

          def insertion(lst):
              for i in range(1,len(lst)):
                  j = <INICIALIZACIÓN DE J>
                  while (j >= 0) and (lst[j+1] < lst[j]):
                      <INTERCAMBIO DE DATOS>
                      j = <ACTUALIZACIÓN DE J>
          ```
          El algorimo empieza con un bucle que recorre toda la lista.
          ¿Qué debería contener el ```<INICIALIZACIÓN DE J>```?
      Hint: Recuerda que la inserción empieza inspeccionando el elemento de su izquierda
      Solution: [3]
      Multiple: no
      Options:
          - len(lst) - 1
          - i
          - i - 1
          - 0
    - Elem: Options
      Content: |
          Seguimos completando el esqueleto de ```insertion(lst)```:

          ```

          def insertion(lst):
              for i in range(1,len(lst)):
                  j = i - 1
                  while (j >= 0) and (lst[j+1] < lst[j]):
                      <INTERCAMBIO DE DATOS>
                      j = <ACTUALIZACIÓN DE J>
          ```
          ¿Qué debería contener el ```<ACTUALIZACIÓN DE J>```?
      Hint: Se debería pasar a inspeccionar el elemento de la izquierda
      Solution: [1]
      Multiple: no
      Options:
          - j - 1
          - j + 1
          - j - i
          - lst[j+1]
    - Elem: Code
      Content: |
          Seguimos completando el esqueleto de ```insertion(lst)```:

          ```

          def insertion(lst):
              for i in range(1,len(lst)):
                  j = i - 1
                  while (j >= 0) and (lst[j+1] < lst[j]):
                      <INTERCAMBIO DE DATOS>
                      j = j - 1
          ```
          Escribe el código de ```<INTERCAMBIO DE DATOS>```
      Gaps: 1
      Hint: Hay que fijarse para no perder el valor de algún elemento de la lista.
      File: correctores/ordenacion/insertion1.py
    - Elem: Text
      Content: |
          # Vista del algoritmo completo

          ```

          def insertion(lst):
              for i in range(1,len(lst)):
                  j = i - 1
                  while (j >= 0) and (lst[j+1] < lst[j]):
                      tmp = lst[j]
                      lst[j] = lst[j + 1]
                      lst[j + 1] = tmp
                      j = j - 1
          ```
 - Title: Ordenación de burbuja
   Elements:
    - Elem: Text
      Content: |
          # Ordenación de burbuja

          El algoritmo de ordenación de burbuja hace múltiples iteraciones de una lista. Compara elementos adyacentes e intercambia aquellos que
          no estén en orden. Cada iteración de la lista deja el siguiente elemento mayor en el lugar apropiado. En esencia, cada elemento
          *burbujea* hacia la posición a la que pertenece.
    - Elem: Text
      Content: |
          # Ideas básicas

          La función ```burbuja(l)``` acepta una lista ```l``` y devuelve una lista ordenada. Para ello sigue estos pasos:
          * Itera los elemento de la lista de 2 en 2. Es decir, primero compara los elementos 0 y 1, luego el 1 con el 2, etc. En cada comparación puede
          ocurrir una de estas dos situaciones:
              1. Que ```l[i]``` sea menor o igual que ```l[i + 1]```. En este caso, no se hace ningún intercambio y la lista queda como estaba.
              1. Que ```l[i]``` sea mayor que ```l[i + 1]```. Se intercambian los valores de las posiciones ```i``` y ```i + 1```.
          * Después de la primera iteración el elemento más grande de la lista queda al final. Por tanto, volvemos a hacer el mismo procedimiento que en el
          punto anterior, solo que esta pararemos en el penúltimo elemento de la lista, que será nuestro nuevo *tope*.
          * Seguiremos el mismo proceso hasta que el *tope* sea el primer elemento, momento en el cual la lista estará ordenada.
    - Elem: Text
      Content: |
          # Ejemplo

          Consideremos la lista desordenada ```l = [3, 2, 4, 1]```. La ejecución de *burbuja(l)* realizaría:
          1. Se comparan ```l[0] = 3``` y ```l[1] = 2```. Como ```l[0]``` es mayor que ```l[1]```, intercambian sus posiciones. De esta manera, se obtiene
          la lista ```l = [2, 3, 4, 1]```.
          1. Se comparan ```l[1] = 3``` y ```l[2] = 4```. Como ```l[1]``` es menor que ```l[2]```, la lista no cambia.
          1. Se comparan ```l[2] = 4``` y ```l[3] = 1```. Como ```l[2]``` es mayor que ```l[3]```, intercambian sus posiciones. De esta manera, se obtiene
          la lista ```l = [2, 3, 1, 4]```.
          1. Empezamos otra vez desde el principio, pero teniendo en cuenta que el tope ahora es ```l[2] = 1```, ya que el mayor elemento de la lista,
          es decir ```4```, ya está en la posición que debe.
          1. Se comparan ```l[0] = 2``` y ```l[1] = 3```. Como ```l[0]``` es menor que ```l[1]```, la lista no cambia.
          1. Se comparan ```l[1] = 3``` y ```l[2] = 1```. Como ```l[1]``` es mayor que ```l[2]```, intercambian sus posiciones. De esta manera, se obtiene
          la lista ```l = [2, 1, 3, 4]```. Ya hemos llagado al tope, por tanto esta iteración ya ha finalizado, y el elemento mayor, es decir ```3```está en
          su sitio.
          1. Empezamos una nueva iteración siendo el tope ```l[1] = 1```.
          1. Se comparan ```l[0] = 2``` y ```l[1] = 1```. Como ```l[0]``` es mayor que ```l[1]```, intercambian sus posiciones. De esta manera, se obtiene
          la lista ```l = [1, 2, 3, 4]```. En este punto el nuevo tope sería ```l[0] = 1```, con lo que ya no se puede comparar con nadie, por tanto, la lista está ya ordenada.
    - Elem: Options
      Content: |
          Siguiendo las ideas y ejemplos anteriores, vamos a intentar completar el esqueleto de la función ```bubble(lst)```
          que implementa la función anterior:

          ```

          def bubble(lst):
              for i in range(len(lst)):
                  j = <INICIALIZACIÓN DE J>
                  tope = <DEFINICIÓN DE TOPE>
                  while(j < tope):
                      if lst[j] > lst[j+1]:
                          <INTERCAMBIO DE DATOS>
                      j = <ACTUALIZACIÓN DE J>
          ```
          ¿Qué debería contener el ```<INICIALIZACIÓN DE J>```?
      Hint: Recuerda que cada iteración vuelve al principio de la lista.
      Solution: [4]
      Multiple: no
      Options:
          - len(lst) - 1
          - i
          - len(lst) - (i + 1)
          - 0
    - Elem: Options
      Content: |
          Seguimos completando el esqueleto de ```bubble(lst)```:

          ```

          def bubble(lst):
              for i in range(len(lst)):
                  j = 0
                  tope = <DEFINICIÓN DE TOPE>
                  while(j < tope):
                      if lst[j] > lst[j+1]:
                          <INTERCAMBIO DE DATOS>
                      j = <ACTUALIZACIÓN DE J>
          ```
          ¿Qué debería contener el ```<DEFINICIÓN DE TOPE>```?
      Hint: El tope va cambiando en cada iteración, siendo primero el último, luego el penúltimo, etc..
      Solution: [3]
      Multiple: no
      Options:
          - len(lst) - 1
          - i + 1
          - len(lst) - (i + 1)
          - len(lst) - i
    - Elem: Options
      Content: |
          Seguimos completando el esqueleto de ```bubble(lst)```:

          ```

          def bubble(lst):
              for i in range(len(lst)):
                  j = 0
                  tope = len(lst) - (i + 1)
                  while(j < tope):
                      if lst[j] > lst[j+1]:
                          <INTERCAMBIO DE DATOS>
                      j = <ACTUALIZACIÓN DE J>
          ```
          ¿Qué debería contener el ```<ACTUALIZACIÓN DE J>```?
      Hint: Recuerda que siempre se comparan pares consecutivos.
      Solution: [3]
      Multiple: no
      Options:
          - j - 1
          - i + 1
          - j + 1
          - j + (i - 1)
    - Elem: Code
      Content: |
          Seguimos completando el esqueleto de ```bubble(lst)```:

          ```

          def bubble(lst):
              for i in range(len(lst)):
                  j = 0
                  tope = len(lst) - (i + 1)
                  while(j < tope):
                      if lst[j] > lst[j+1]:
                          <INTERCAMBIO DE DATOS>
                      j = j + 1
          ```
          Escribe el código de ```<INTERCAMBIO DE DATOS>```
      Gaps: 1
      Hint: Hay que fijarse para no perder el valor de algún elemento de la lista.
      File: correctores/ordenacion/bubble1.py
    - Elem: Text
      Content: |
          # Vista del algoritmo completo

          ```

          def bubble(lst):
              for i in range(len(lst)):
                  j = 0
                  tope = len(lst) - (i + 1)
                  while(j < tope):
                      if lst[j] > lst[j+1]:
                          tmp = lst[j]
                          lst[j] = lst[j+1]
                          lst[j+1] = tmp
                      j = j + 1
          ```
 - Title: Quicksort
   Elements:
    - Elem: Text
      Content: |
          # Quicksort

          Los algoritmos de ordenación que acabáis de aprender son los conocidos como *cuadráticos*, ya que en el peor
          de los casos deben hacer una cantidad de comparaciones proporcional a @@n^2@@ para ordenar una lista de
          tamaño @@n@@. A continuación aprenderemos el
          algoritmo **quicksort**, que permite reducir el número de comparaciones a @@n \times \mathit{log}~n@@ en el caso
          promedio. Por lo tanto, permite ordenar listas en menos tiempo que la ordenación por *inserción*, *selección*
          o *burbuja*.
          Otra diferencia es que este algoritmo es recursivo, mientras que los anteriores eran iterativos.
    - Elem: Text
      Content: |
          # Ideas básicas

          La función ```quicksort(l)``` acepta una lista ```l``` y devuelve una lista ordenada. Para ello sigue estos pasos:
          * Si la lista está **vacía** o tiene **un único elemento** entonces ya está ordenada y únicamente hay que devolver esa misma lista.
          * En otro caso, toma un elemento de la lista de manera aleatoria (usualmente el primer elemento). Este elemento escogido se conoce como **pivote**.
              1. Divide la lista (sin contar el pivote) en dos partes. Por un lado toma los elementos menores o iguales que el pivote y por otro los elementos mayores que el pivote.
              1. De manera recursiva, se ordenan estas dos listas más pequeñas.
              1. Finalmente, las listas ordenadas se concatenan con el pivote en la mitad.
    - Elem: Text
      Content: |
          # Ejemplo

          Consideremos la lista desordenada ```l = [5, 7, 3, 1]```. La ejecución de *quicksort* realizaría:
          1. Como ```l``` no es una lista vacía ni unitaria, se toma ```5``` como **pivote**.
          1. Se divide la lista restante ```[7, 3, 1]```` en dos partes (recuerda que se ignora el pivote). Esto creará dos listas:
              * ```less_eq = [3, 1]```
              * ```greater = [7]```
          1. A continuación, se ordena cada una de estas listas de manera recursiva invocando a ```quicksort```. Esto creará otras dos listas:
              * ```sorted_less_eq = [1, 3]```
              * ```sorted_greater = [7]```
          1. Finalmente concatenamos ```sorted_less_eq``` seguido del pivote y de ```sorted_greater```. El resultado de
             esta concatenación será ```[1, 3] + [5] + [7] = [1, 3, 5, 7]```, es decir, la lista ordenada.
    - Elem: Text
      Content: |
          # Funciones auxiliares

          Para implementar el algoritmo *quicksort* es necesario ser capaces de, a partir de una lista, elegir un
          pivote y dividir la lista en dos partes: los elementos menores o iguales y los elementos mayores.

          La función auxiliar ```partition(l)``` realiza ese trabajo. Para ello selecciona el primer elemento como pivote
          ```piv``` y recorre el resto de la lista mediante un bucle ```while```. Cada vez que encuentra un elemento menor o igual que el pivote lo
          almacena en la lista ```less_eq```, y cada vez que encuentra un elemento mayor que el pivote lo almacena en la
          lista ```greater```.
          ```

          def partition(l):
              piv = l[0]
              i = 1
              less_eq = []
              greater = []
              while i < len(l):
                  current = l[i]
                  if current <= piv:
                      less_eq.append(current)
                  else:
                      greater.append(current)
                  i = i + 1
              return (less_eq, piv, greater)
          ```
          Finalmente, la función ```partition``` devuelve una tupla de 3 elementos: la lista ```less_eq```, el pivote
          ```piv``` y la lista ```greater```.
    - Elem: Options
      Content: |
          Considerando el código de la función ```partition``` presentado anteriormente:

          ```

          def partition(l):
              piv = l[0]
              i = 1
              less_eq = []
              greater = []
              while i < len(l):
                  current = l[i]
                  if current <= piv:
                      less_eq.append(current)
                  else:
                      greater.append(current)
                  i = i + 1
              return (less_eq, piv, greater)
          ```
          ¿Qué debería devolver la siguiente llamada ```partition([])```?
      Hint: Revisa bien cómo se elige el pivote.
      Solution: [4]
      Multiple: no
      Options:
          - La tupla ([], None, [])
          - La tupla ([], [])
          - La lista vacía []
          - Debería fallar al tratar de acceder al primer elemento de la lista vacía.
    - Elem: Code
      Content: |
          Considerando de nuevo el código de la función ```partition``` presentado anteriormente:

          ```

          def partition(l):
              piv = l[0]
              i = 1
              less_eq = []
              greater = []
              while i < len(l):
                  current = l[i]
                  if current <= piv:
                      less_eq.append(current)
                  else:
                      greater.append(current)
                  i = i + 1
              return (less_eq, piv, greater)
          ```
          ¿Qué debería devolver la llamada ```partition([6,3,9,2,4])```?
      Gaps: 1
      Prompt: ["Valor devuelto por partition([6,3,9,2,4])"]
      Hint: ¿Qué elemento tiene que ir a cada lista? ¿Qué elemento es el pivote?
      File: correctores/ordenacion/quicksort1.py
    - Elem: Code
      Content: |
          Considerando de nuevo el código de la función ```partition``` presentado anteriormente:

          ```

          def partition(l):
              piv = l[0]
              i = 1
              less_eq = []
              greater = []
              while i < len(l):
                  current = l[i]
                  if current <= piv:
                      less_eq.append(current)
                  else:
                      greater.append(current)
                  i = i + 1
              return (less_eq, piv, greater)
          ```
          ¿Qué debería devolver la llamada ```partition([1,2,3,4,5])```?
      Gaps: 1
      Prompt: ["Valor devuelto por partition([1,2,3,4,5])"]
      Hint: ¿Qué elemento tiene que ir a cada lista? ¿Qué elemento es el pivote?
      File: correctores/ordenacion/quicksort2.py
    - Elem: Text
      Content: |
          # Código de ```quicksort```

          Utilizando la función ```partition``` es muy sencillo implementar la función ```quicksort``` para ordenar
          listas:

          ```

          def quicksort(l):
              # Base case, the same list is returned.
              if len(l) <= 1:
                  return l
              # Recursive case:
              else:
                  (less_eq, piv, greater) = partition(l)
                  sorted_less_eq = quicksort(less_eq)
                  sorted_greater = quicksort(greater)
                  return sorted_less_eq + [piv] + sorted_greater
          ```

          Si la longitud de la lista es igual o inferior a 1 (```len(l) <= 1```) entonces está ordenada y se puede devolver
          directamente.

          En otro caso se invoca a ```partition``` para obtener el pivote ```piv``` y las listas de elementos
          menores o iguales (```less_eq```) y mayores (```greater```). A continuación se ordenan estas listas de manera
          recursiva con llamadas a ```quicksort```:
          * sorted_less_eq = ```quicksort(less_eq)```
          * sorted_greater = ```quicksort(greater)```

          Finalmente, se devuelven los elementos menores o iguales **ordenados**, seguidos del pivote y de los elementos
          mayores **ordenados**. Esta operación se realiza con la siguiente concatenación de listas:
          ```

          return sorted_less_eq + [piv] + sorted_greater
          ```
          Notad que el operador ```+``` concatena listas, por lo que debemos crear la lista unitaria ```[piv]``` para que la
          concatenación de las 3 partes tenga éxito.
    - Elem: Code
      Content: |
          Vamos a comprobar que habéis entendido bien el código de quicksort. **Sin volver atrás** para revisar el
          código, trata de rellenar los huecos ```<Hueco 0>``` y ```<Hueco 1>``` en el siguiente código. En estos
          huecos deberían aparecer las llamadas recursivas.

          ```

          def quicksort(l):
              # Base case, the same list is returned.
              if len(l) <= 1:
                  return l
              # Recursive case:
              else:
                  (less_eq, piv, greater) = partition(l)
                  sorted_less_eq = <Hueco 0>
                  sorted_greater = <Hueco 1>
                  return sorted_less_eq + [piv] + sorted_greater
          ```
      Gaps: 2
      Hint: quicksort() deber ordenar las partes separadas por partition()
      File: correctores/ordenacion/quicksort3.py
    - Elem: Code
      Content: |
          Por último, vamos a comprobar las intuiciones que habéis formado sobre el código de ```quicksort```.
          ¿Qué valor debería tomar la variable ```sorted_less_eq``` en la llamada inicial de

          ```

          quicksort([6,2,7,3,8,0])
          ```

          A modo de recordatorio, el código de ```quicksort``` es el siguiente:
          ```

          def quicksort(l):
              # Base case, the same list is returned.
              if len(l) <= 1:
                  return l
              # Recursive case:
              else:
                  (less_eq, piv, greater) = partition(l)
                  sorted_less_eq = quicksort(less_eq)
                  sorted_greater = quicksort(greater)
                  return sorted_less_eq + [piv] + sorted_greater
          ```
      Gaps: 1
      Prompt: ["Valor de sorted_less_eq"]
      Hint: Trata de calcular los valores que van tomando las variables anteriores a sorted_less_eq.
      File: correctores/ordenacion/quicksort4.py
    - Elem: Code
      Content: |
          Considerando de nuevo la llamada

          ```

          quicksort([6,2,7,3,8,0])
          ```

          ¿Qué valor debería tomar la variable ```sorted_greater``` en la llamada inicial?
          A modo de recordatorio, el código de ```quicksort``` es el siguiente:
          ```

          def quicksort(l):
              # Base case, the same list is returned.
              if len(l) <= 1:
                  return l
              # Recursive case:
              else:
                  (less_eq, piv, greater) = partition(l)
                  sorted_less_eq = quicksort(less_eq)
                  sorted_greater = quicksort(greater)
                  return sorted_less_eq + [piv] + sorted_greater
          ```
      Gaps: 1
      Prompt: ["Valor de sorted_greater"]
      Hint: Trata de calcular los valores que van tomando las variables anteriores a sorted_greater.
      File: correctores/ordenacion/quicksort5.py
 - Title: Mergesort
   Elements:
    - Elem: Text
      Content: |
          # Mergesort

          El algoritmo **mergesort** es otro algoritmo de ordenación *rápido*, al igual que *quicksort*. En otras
          palabras, para ordenar una lista de @@n@@ elementos necesitará realizar como mucho @@n \times \mathit{log}~n@@
          comparaciones, en lugar de las @@n^2@@ de la ordenación por *inserción*, *selección* o *burbuja*.

          Las ideas principales son similares a *quicksort*: dividir la lista original en dos partes,
          ordenar cada parte y por último componer la lista completa ordenada a partir de sus partes ordenadas. Sin
          embargo, difiere en cómo realiza la división de la lista, como veremos más adelante.
    - Elem: Text
      Content: |
          # Ideas básicas

          El algoritmo **mergesort** ordena una lista dividiéndola en **2 mitades**, ordenando cada mitad resultante y
          por último combinando esas 2 mitades ordenadas utilizando una función auxiliar ```merge```.

          La función ```merge```
          combina dos listas ordenadas manteniendo el orden de sus elementos, es decir,
          cogiendo en cada momento el menor elemento que
          aparece en las cabeza de las listas.

          Concretamente, ```mergesort``` realiza los siguientes pasos:
          * Si la lista está **vacía o tiene un solo elemento** ya está ordenada y se devuelve directamente.
          * Si la lista tiene **2 o más elementos**:
            1. Divide la lista original en dos mitades
            1. Invoca recursivamente al método ```mergesort``` para ordenar cada mitad de lista
            1. Finalmente, combina las dos mitades ordenadas mediante la función auxiliar ```merge```. El resultado de
               esta combinación es la lista original ordenada, que se devuelve.
    - Elem: Text
      Content: |
          # Ejemplo

          Consideremos la lista desordenada ```l = [5, 7, 3, 1]```. La ejecución de *mergesort* realizaría:
          1. Como ```l``` no es una lista vacía se divide en 2 mitades. La posición central será ```half = len(l) // 2```,
             que en este caso es ```4 // 2 = 2```. Nótese el uso de la división entera para evitar decimales al tratar
             listas de longitud impar.
          1. Se divide la lista original ```l``` en dos mitades: ```l1 = l[:half]``` con los elementos en posiciones desde
             ```0``` hasta ```half-1```, y ```l2 = l[half:]``` con los elementos en posiciones desde ```half``` hasta el
             final de la lista. En este caso:
               * ```l1 = [5, 7]```
               * ```l2 = [3, 1]```
          1. Cada una de estas listas se ordena de manera recursiva, obteniendo dos mitades ordenadas.
               * ```sorted_l1 = [5, 7]```
               * ```sorted_l2 = [1, 3]```
          1. Finalmente se mezclan de manera ordenada ambas listas ordenadas usando la función auxiliar ```merge```,
             generando la lista inicial ordenada ```[1, 3, 5, 7]```
    - Elem: Text
      Content: |
          # Función ```merge```

          Antes de ver el código concreto de ```mergesort``` estudiaremos la función auxiliar ```merge```. Esta función
          toma dos **listas ordenadas** ```l1``` y ```l2``` y las combina de manera ordenada, generando una lista ordenada
          ```merged_list```. Para ello recorre ambas listas en orden usando dos índices ```i``` y ```j```:
          * ```i```: posición del siguiente elemento a procesar de la lista ```l1```.
          * ```j```: posición del siguiente elemento a procesar de la lista ```l2```.

          En cada momento, compara ```l1[i]``` y ```l2[j]```:
          * Si ```l1[i] <= l2[j]``` entonces inserta ```l1[i]``` al final de la lista ordenada ```merged_list``` ya que es menor
            o igual a ```l2[j]``` y por tanto debería ir antes. Como se ha procesado el elemento ```l1[i]``` se incrementa el
            índice ```i```.
          * Si no, ```l1[i] > l2[j]``` e inserta ```l2[j]``` al final de la lista ordenada ```merged_list```.
            Como se ha procesado el elemento ```l2[j]``` se incrementa el índice ```j```.

          Este proceso se repite hasta que una de las dos listas se acaba (o bien ```i == len(l1)``` o bien ```j == len(l2)```).
          En ese momento se deja de comparar elementos y se añaden a la lista ordenada ```merged_list``` los elementos
          restantes de la lista que aún tiene elementos por procesar.
    - Elem: Text
      Content: |
          # Código de la función ```merge```

          El código concreto de la función ```merge``` sería el siguiente:

          ```

          def merge(l1, l2):
              i = 0
              j = 0
              merged_list = []
              while i < len(l1) and j < len(l2):
                  if l1[i] <= l2[j]:
                      merged_list.append(l1[i])
                      i = i + 1
                  else:
                      merged_list.append(l2[j])
                      j = j + 1
              while i < len(l1):
                  merged_list.append(l1[i])
                  i = i + 1
              while j < len(l2):
                  merged_list.append(l2[j])
                  j = j + 1
              return merged_list
          ```

          Esta función contiene 3 bucles ```while```:
          1. El primer bucle recorre en orden y compara los elementos ```l1[i]``` y ```l2[j]``` hasta que una de las
             dos listas se termina. En cada iteración añade un nuevo elemento a la lista ordenada ```merged_list```.
          1. El segundo bucle recorre los posibles elementos restantes de ```l1``` y los añade en orden a la lista ordenada ```merged_list```.
          1. El tercer bucle recorre los posibles elementos restantes de ```l2``` y los añade en orden a la lista ordenada ```merged_list```.

          Es importante darse cuenta de que al terminar el primer bucle se habrá terminado de recorrer exactamente una de las 2 listas.
          Si es la primera lista entonces ```i == len(l1)``` y no se entrará en el segundo bucle. Si es la segunda lista la que
          se ha terminado de recorrer entonces ```j == len(l2)``` y no se entrará en el tercer bucle. Se podría haber realizado
          una distinción de casos para elegir qué bucle ejecutar, pero la propia condición de los bucles segundo y tercero
          consigue que únicamente se entre en uno de ellos.
    - Elem: Options
      Content: |
          Considerando el código de la función ```merge``` presentado anteriormente:
          ```

          def merge(l1, l2):
              i = 0
              j = 0
              merged_list = []
              while i < len(l1) and j < len(l2):
                  if l1[i] <= l2[j]:
                      merged_list.append(l1[i])
                      i = i + 1
                  else:
                      merged_list.append(l2[j])
                      j = j + 1
              while i < len(l1):
                  merged_list.append(l1[i])
                  i = i + 1
              while j < len(l2):
                  merged_list.append(l2[j])
                  j = j + 1
              return merged_list
          ```

          ¿Qué debería devolver la siguiente llamada ```merge([],[])```?
      Hint: Revisa bien las condiciones de los distintos bucles.
      Solution: [3]
      Multiple: no
      Options:
        - None
        - (None, None)
        - []
        - ([], [])
    - Elem: Options
      Content: |
          Siguiendo con el código de la función ```merge``` presentado anteriormente:
          ```

          def merge(l1, l2):
              i = 0
              j = 0
              merged_list = []
              while i < len(l1) and j < len(l2):
                  if l1[i] <= l2[j]:
                      merged_list.append(l1[i])
                      i = i + 1
                  else:
                      merged_list.append(l2[j])
                      j = j + 1
              while i < len(l1):
                  merged_list.append(l1[i])
                  i = i + 1
              while j < len(l2):
                  merged_list.append(l2[j])
                  j = j + 1
              return merged_list
          ```

          ¿Qué debería devolver la llamada ```merge([8],[1,9])```?
      Hint: Revisa bien las condiciones de los distintos bucles.
      Solution: [1]
      Multiple: no
      Options:
        - [1, 8, 9]
        - [8, 1, 9]
        - [1, 9, 8]
    - Elem: Code
      Content: |
          Otra pregunta más sobre la función auxiliar ```merge```.

          ```

          def merge(l1, l2):
              i = 0
              j = 0
              merged_list = []
              while i < len(l1) and j < len(l2):
                  if l1[i] <= l2[j]:
                      merged_list.append(l1[i])
                      i = i + 1
                  else:
                      merged_list.append(l2[j])
                      j = j + 1
              while i < len(l1):
                  merged_list.append(l1[i])
                  i = i + 1
              while j < len(l2):
                  merged_list.append(l2[j])
                  j = j + 1
              return merged_list
          ```

          ¿Qué debería devolver la llamada ```merge([1,4,8],[])```?
      Gaps: 1
      Prompt: ["Resultado de merge([1,4,8],[])"]
      Hint: Trata de ver qué bucles se ejecutarán.
      File: correctores/ordenacion/mergesort1.py
    - Elem: Options
      Content: |
          Ya estamos familiarizados con la función auxiliar ```merge``` que mezcla de manera ordenada dos listas ordenadas.
          Pero, ¿qué pasaría si se invoca con listas que no están ordenadas? Por ejemplo, con la siguiente invocación:

          ```

          merge([5, 1], [3, 2])
          ```

          ¿Qué produciría la invocación anterior?
      Hint: Revisa bien las condiciones de los distintos bucles.
      Solution: [2]
      Multiple: no
      Options:
        - Lanza un error en tiempo de ejecución
        - Genera una lista de 4 elementos pero desordenada
        - Genera la lista ordenada [1, 2, 3, 5]
        - Genera la lista de 2 elementos [1, 5] ya que únicamente recorre la primera lista
    - Elem: Text
      Content: |
          # Versión alternativa de ```merge```

          El código de la función auxiliar ```merge``` se puede simplificar si utilizamos dos métodos de las listas:
            * ```l.pop(n)``` para eliminar el elemento en posición ```n``` de la lista ```l```
            * ```l.extend(l1)``` para concatenar ```l1``` al final de ```l```

          Con estos dos métodos podríamos eliminar completamente el uso de los índices ```i``` y ```j``` e implementar ```merge``` como sigue:
          ```

          def merge_bis(l1, l2):
              merged_list = []
              while l1 != [] and l2 != []:
                  if l1[0] <= l2[0]:
                      merged_list.append(l1[0])
                      l1.pop(0)
                  else:
                      merged_list.append(l2[0])
                      l2.pop(0)
              merged_list.extend(l1)
              merged_list.extend(l2)
              return merged_list
          ```
          Como se puede ver, las listas ```l1``` y ```l2``` se van vaciando con ```pop[0]``` y la condición del primer
          bucle comprueba que las listas ```l1``` y ```l2``` no sean vacías. Finalmente, usamos ```merge_list.extend(l1)```
          y ```merge_list.extend(l2)``` para concatenar los elementos restantes. De manera similar a la versión anterior
          de ```merge```, al terminar el primer bucle tenemos la certeza que **una de las dos listas (```l1``` o ```l2```)
          estará vacía**.
    - Elem: Text
      Content: |
          # Código de ```mergesort```

          Disponiendo de una función auxiliar ```merge``` (o ```merge_bis```) es bastante sencillo implementar la función de ordenación
          ```mergesort```:

          ```

          def mergesort(l):
              if len(l) <= 1:
                  return l
              else:
                  half = (len(l) // 2)
                  l1 = mergesort(l[:half])
                  l2 = mergesort(l[half:])
                  return merge(l1, l2)
          ```
          Si la lista está **vacía o tiene un solo elemento** ya está ordenada y se devuelve directamente.

          En otro caso (la lista tiene **2 o más elementos**) se divide la lista en 2 mitades. Para ello se calcula la
          posición central de la lista con la asignación ```half = (len(l) // 2)```, que usa la división entera.

          A continuación invoca de manera recursiva a ```mergesort``` con cada una de las dos mitades:
            1. La primera mitad de la lista será ```l[:half]```: *posiciones [0..half)*
            1. La segunda mitad de la lista será ```l[half:]```: *posiciones [half..n)*, siendo *n* la longitud de ```l```

          El resultado de las dos llamadas recursivas serán dos mitades ordenadas ```l1``` y ```l2```. Por lo tanto el
          último paso será mezclar de manera ordenadas ambas mitades ordenadas. Para ello invocaremos a la función
          auxiliar ```merge```.
    - Elem: Code
      Content: |
          Vamos a comprobar que habéis entendido bien el código de ```mergesort```. **Sin volver atrás** para revisar el
          código, trata de rellenar los huecos ```<Hueco 0>``` y ```<Hueco 1>``` en el siguiente código.

          ```

          def mergesort(l):
              if len(l) <= 1:
                  return lst
              else:
                  half = <Hueco 0>
                  l1 = mergesort(l[:half])
                  l2 = mergesort(l[half:])
                  return <Hueco 1>
          ```
      Gaps: 2
      Hint: Habría que calcular la mitad y combinar de alguna manera las listas l1 y l2
      File: correctores/ordenacion/mergesort2.py
    - Elem: Code
      Content: |
          Por último, vamos a comprobar las intuiciones que habéis formado sobre el código de ```mergesort```.
          ¿Qué valor debería tomar la variable ```l1``` en la llamada inicial de

          ```

          mergesort([6,8,2,4,1])
          ```

          A modo de recordatorio, el código de ```mergesort``` es el siguiente:
          ```

          def mergesort(l):
              if len(l) <= 1:
                  return l
              else:
                  half = (len(l) // 2)
                  l1 = mergesort(l[:half])
                  l2 = mergesort(l[half:])
                  return merge(l1, l2)
          ```
      Gaps: 1
      Prompt: ["Valor de la variable l1"]
      Hint: Es el resultado de una llamada recursiva con un trozo de la lista original.
      File: correctores/ordenacion/mergesort3.py
    - Elem: Code
      Content: |
          Y considerando la misma llamada

          ```

          mergesort([6,8,2,4,1])
          ```
          ¿Qué valor debería tomar la variables ```l2```?

          Al igual que antes, a modo de recordatorio el código de ```mergesort``` es el siguiente:
          ```

          def mergesort(l):
              if len(l) <= 1:
                  return l
              else:
                  half = (len(l) // 2)
                  l1 = mergesort(l[:half])
                  l2 = mergesort(l[half:])
                  return merge(l1, l2)
          ```
      Gaps: 1
      Prompt: ["Valor de la variable l2"]
      Hint: Es el resultado de una llamada recursiva con un trozo de la lista original.
      File: correctores/ordenacion/mergesort4.py
