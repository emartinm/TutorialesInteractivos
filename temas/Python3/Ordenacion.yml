Subject: 6
Title: Algoritmos de ordenación
Intro: bla bla bla
Lessons:
 - Title: Introducción
   Elements:
    - Elem: Text
      Content: |
          bla bla bla
 - Title: Ordenación por selección
   Elements:
    - Elem: Text
      Content: |
          bla bla bla
 - Title: Ordenación por inserción
   Elements:
    - Elem: Text
      Content: |
          bla bla bla
 - Title: Ordenación de burbuja
   Elements:
    - Elem: Text
      Content: |
          bla bla bla          
 - Title: Quicksort
   Elements:
    - Elem: Text
      Content: |
          # Quicksort

          Los algoritmos de ordenación que acabáis de aprender son los conocidos como *cuadráticos*, ya que en el peor
          de los casos deben hacer una cantidad de comparaciones proporcional a @@n^2@@. A continuación aprenderemos el
          algoritmo **quicksort**, que permite reducir el número de comparaciones @@n.\mathit{log}~n@@ en el caso
          promedio. Por lo tanto, permite ordenar listas en menos tiempo que la ordenación por *inserción*, *selección*
          o *burbuja*.
    - Elem: Text
      Content: |
          # Ideas básicas

          La función ```quicksort(l)``` acepta una lista ```l``` y devuelve una lista ordenada. Para ello sigue estos pasos:
          * Si la lista está **vacía** o tiene **un único elemento** entonces ya está ordenada y únicamente hay que devolver la lista.
          * En otro caso, toma un elemento de la lista de manera aleatoria (usualmente el primer elemento). Este elemento escogido se conoce como **pivote**.
              1. Divide la lista (sin contar el pivote) en dos partes. Para ello toma por un lado los elementos menores o iguales que el pivote y por otro los elementos mayores que el pivote.
              1. De manera recursiva, se ordenan estas dos listas más pequeñas.
              1. Finalmente, las listas ordenadas se concatenan con el pivote en la mitad.
    - Elem: Text
      Content: |
          # Ejemplo

          Consideremos la lista desodenada ```l = [5, 7, 3, 1]```. La ejecución de *quicksort* realizaría:
          1. Como ```l``` no es una lista vacía, se toma ```5``` como **pivote**.
          1. Se divide la lista restante ```[7, 3, 1]```` en dos partes (recuerda que se ignora el pivote). Esto creará dos listas:
              * ```less_eq = [3, 1]```
              * ```greater = [7]```
          1. A continuación, se ordena cada una de estas listas de manera recursiva invocando a ```quicksort```. Esto creará otras dos listas:
              * ```sorted_less_eq = [1, 3]```
              * ```sorted_greater = [7]```
          1. Finalmente concatenamos ```sorted_less_eq``` seguido del pivote y de ```sorted_greater```. El resultado de
             esta concatenación será ```[1, 3] + [5] + [7] = [1, 3, 5, 7]```, es decir, la lista ordenada.
    - Elem: Text
      Content: |
          # Funciones auxiliares

          Para implementar el algoritmo *quicksort* es necesario ser capaces de, a partir de una lista, elegir un
          pivote y dividir la lista en los partes: los elementos menores o iguales y los elementos mayores.

          La función auxiliar ```partition(l)``` realiza ese trabajo. Para ello selecciona el primer elemento como pivote
          ```piv``` y recorre el resto de la lista mediante un bucle ```while```. Cada vez que encuentra un elemento menor o igual que pivote lo
          almacena en la lista ```less_eq```, y cada vez que encuentra un elemento mayor que pivote lo almacena en la
          lista ```greater```.
          ```

          def partition(l):
              piv = l[0]
              i = 1
              less_eq = []
              greater = []
              while i < len(l):
                  current = l[i]
                  if current <= piv:
                      less_eq.append(current)
                  else:
                      greater.append(current)
                  i = i + 1
              return (less_eq, piv, greater)
          ```
          Finalmente, la función ```partition``` devuelve una tupla de 3 elementos: la lista ```less_eq```, el pivote
          ```piv``` y la lista ```greater```.
    - Elem: Options
      Content: |
          Considerando el código de la función ```partition``` presentado anteriormente:

          ```

          def partition(l):
              piv = l[0]
              i = 1
              less_eq = []
              greater = []
              while i < len(l):
                  current = l[i]
                  if current <= piv:
                      less_eq.append(current)
                  else:
                      greater.append(current)
                  i = i + 1
              return (less_eq, piv, greater)
          ```
          ¿Qué debería devolver la siguiente llamada ```partition([])```?
      Hint: Revisa bien cómo se elige el pivote.
      Solution: [4]
      Multiple: no
      Options:
          - La tupla ([], None, [])
          - La tupla ([], [])
          - La lista vacía []
          - Debería fallar al tratar de acceder al primer elemento de la lista vacía.
    - Elem: Code
      Content: |
          Considerando de nuevo el código de la función ```partition``` presentado anteriormente:

          ```

          def partition(l):
              piv = l[0]
              i = 1
              less_eq = []
              greater = []
              while i < len(l):
                  current = l[i]
                  if current <= piv:
                      less_eq.append(current)
                  else:
                      greater.append(current)
                  i = i + 1
              return (less_eq, piv, greater)
          ```
          ¿Qué debería devolver la llamada ```partition([6,3,9,2,4])```?
      Gaps: 1
      Prompt: ["Valor devuelto por partition([6,3,9,2,4])"]
      Hint: ¿Qué elemento tiene que ir a cada lista? ¿Qué elemento es el pivote?
      File: correctores/ordenacion/quicksort1.py
    - Elem: Code
      Content: |
          Considerando de nuevo el código de la función ```partition``` presentado anteriormente:

          ```

          def partition(l):
              piv = l[0]
              i = 1
              less_eq = []
              greater = []
              while i < len(l):
                  current = l[i]
                  if current <= piv:
                      less_eq.append(current)
                  else:
                      greater.append(current)
                  i = i + 1
              return (less_eq, piv, greater)
          ```
          ¿Qué debería devolver la llamada ```partition([1,2,3,4,5])```?
      Gaps: 1
      Prompt: ["Valor devuelto por partition([1,2,3,4,5])"]
      Hint: ¿Qué elemento tiene que ir a cada lista? ¿Qué elemento es el pivote?
      File: correctores/ordenacion/quicksort2.py
    - Elem: Text
      Content: |
          # Código de ```quicksort```

          Utilizando la función ```partition``` es muy sencillo implementar la función ```quicksort``` para ordenar
          listas:

          ```

          def quicksort(l):
              # Base case, the same list is returned.
              if len(l) <= 1:
                  return l
              # Recursive case:
              else:
                  (less_eq, piv, greater) = partition(l)
                  sorted_less_eq = quicksort(less_eq)
                  sorted_greater = quicksort(greater)
                  return sorted_less_eq + [piv] + sorted_greater
          ```

          Si la longitud de la lista es igual o inferior a 1 (```len(l) <= 1```) entonces está ordenada y se puede devolver
          directamente.

          En otro caso se invoca a ```partition``` para obtener el pivote ```piv``` y las listas de elementos
          menores o iguales (```less_eq```) y mayores (```greater```). A continuación se ordenan estas listas de manera
          recursiva con llamadas a ```quicksort```:
          * sorted_less_eq = ```quicksort(less_eq)```
          * sorted_greater = ```quicksort(greater)```

          Finalmente, se devuelven los elementos menores o iguales **ordenados**, seguidos del pivote y de los elementos
          mayores **ordenados**. Esta operación se realiza con la siguiente concatenación de listas:
          ```

          return sorted_less_eq + [piv] + sorted_greater
          ```
          Notad que el operador ```+``` concatena listas, por lo que debemos crear la lista unitaria ```[piv]``` para que la
          concatenación de las 3 partes tenga éxito.
    - Elem: Code
      Content: |
          Vamos a comprobar que habéis entendido bien el código de quicksort. **Sin volver atrás** para revisar el
          código, trata de rellenar los huecos ```<Hueco 0>``` y ```<Hueco 1>``` en el siguiente código. En estos
          huecos deberían aparecer las llamadas recursivas.

          ```

          def quicksort(l):
              # Base case, the same list is returned.
              if len(l) <= 1:
                  return l
              # Recursive case:
              else:
                  (less_eq, piv, greater) = partition(l)
                  sorted_less_eq = <Hueco 0>
                  sorted_greater = <Hueco 1>
                  return sorted_less_eq + [piv] + sorted_greater
          ```
      Gaps: 2
      Hint: quicksort() deber ordenar las partes separadas por partition()
      File: correctores/ordenacion/quicksort3.py
    - Elem: Code
      Content: |
          Por último, vamos a comprobar las intuiciones que habéis formado sobre el código de ```quicksort```.
          ¿Qué valor debería tomar la variable ```sorted_less_eq``` en la llamada inicial de

          ```

          quicksort([6,2,7,3,8,0])
          ```

          A modo de recordatorio, el código de ```quicksort``` es el siguiente:
          ```

          def quicksort(l):
              # Base case, the same list is returned.
              if len(l) <= 1:
                  return l
              # Recursive case:
              else:
                  (less_eq, piv, greater) = partition(l)
                  sorted_less_eq = quicksort(less_eq)
                  sorted_greater = quicksort(greater)
                  return sorted_less_eq + [piv] + sorted_greater
          ```
      Gaps: 1
      Prompt: ["Valor de sorted_less_eq"]
      Hint: Trata de calcular los valores que van tomando las variables anteriores a sorted_less_eq.
      File: correctores/ordenacion/quicksort4.py
    - Elem: Code
      Content: |
          Y considerando la misma llamada

          ```

          quicksort([6,2,7,3,8,0])
          ```

          ¿Qué valor debería tomar la variable ```sorted_greater``` en la llamada inicial?
          A modo de recordatorio, el código de ```quicksort``` es el siguiente:
          ```

          def quicksort(l):
              # Base case, the same list is returned.
              if len(l) <= 1:
                  return l
              # Recursive case:
              else:
                  (less_eq, piv, greater) = partition(l)
                  sorted_less_eq = quicksort(less_eq)
                  sorted_greater = quicksort(greater)
                  return sorted_less_eq + [piv] + sorted_greater
          ```
      Gaps: 1
      Prompt: ["Valor de sorted_greater"]
      Hint: Trata de calcular los valores que van tomando las variables anteriores a sorted_greater.
      File: correctores/ordenacion/quicksort5.py
 - Title: Mergesort
   Elements:
    - Elem: Text
      Content: |
          bla bla bla
